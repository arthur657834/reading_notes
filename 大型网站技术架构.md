高并发，大流量
高可用
海量数据
用户分布广泛，网络复杂
安全环境恶劣
需求快速变更，发布频繁
渐进式发展

是业务成就了技术，事业成就了个人

不要一味追求大公司对解决方案
为了技术而技术
企图用技术解决一切

分层:
1. 应用层
    * 视图层
    * 业务逻辑层
2. 服务层
    * 数据接口层
    * 逻辑处理层
3. 数据层

Tips:
* 层次边界和接口
* 禁止跨层次调用和逆向调用

横向分层，纵向分割

分布式：
* 网络通信，性能损耗
* 可用性
* 数据一致性

分布式方案：
* 分布式应用和服务
* 分布式静态资源
* 分布式数据和存储
* 分布式计算
* 分布式锁
* 分布式配置
* 分布式文件

集群

缓存：
* CDN
* 反向代理
* 本地缓存
* 分布式缓存

异步消息队列:
* 提高系统可用性
* 加快网站响应速度
* 消除并发访问高峰

用户体验可能会受影响

网站冗余:
* 冷备
* 热备


* 性能
* 可用性
* 伸缩性:
  1. 新增机器可以提供与原服务器无差别的服务，集群可容纳的机器数是否有限制
  2. 对无数据存储的应用服务器来说，地位对等
* 扩展性
* 安全

削峰

不同视角下性能测试:
* 用户: 网页响应等
* 开发: 程序快慢等
* 运维: 带宽，资源利用率等

性能指标:
* 响应时间
* 并发数
* 吞吐量
  1. TPS 每秒事务数
  2. HPS 每秒http请求数
  3. QPS 每秒查询数
* 性能计数器 systemload

性能测试:符合性能预期
负载测试
压力测试
稳定性测试

web前端优化
减少http请求
浏览器缓存
压缩
css置于页面上方
减少cookie传输

写一次缓存，最少读取两次

缓存雪崩: 严重依赖缓存服务器，当缓存服务器崩溃以后服务器无法处理大规模数据

缓存预热: 新增加的缓存服务器在启动时就加载一部分数据

缓存穿透攻击


jboss cache:同步更新的分布式缓存
memcache:互不通信的分布式缓存
优缺点是啥

任何可以晚点做的事都应该晚点做

代码优化
资源复用
多线程   要不要将对象设计为无状态
内存回收
数据结构

B+树 LSM树

raid0:多块硬盘并发读写
raid1:一份数据两次不同硬盘
raid10: raid0+raid1
raid3:数据分成n-1份写入，在N盘上做数据校验
raid5:数据分成n-1份写入，螺旋在所有盘上做数据校验
raid6:数据分成n-2份写入，螺旋在2盘上做数据校验


hdfs

网站不可用时间
网站年度不可用时间

session管理：
复制
绑定 会话黏滞
cookie记录session
session服务器


分级管理
超时设置
异步调用
服务降级
  拒绝服务
  关闭服务
幂等设计

CAP:
  * Consistency(一致性), 数据一致更新，所有数据变动都是同步的
  * Availability(可用性), 好的响应性能
  * Partition tolerance(分区容错性) 可靠性

定理：任何分布式系统只可同时满足二点，没法三者兼顾。

关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区：
  * Atomicity原子性: 一个事务中所有操作都必须全部完成，要么全部不完成。
  * Consistency一致性: 在事务开始或结束时，数据库应该在一致状态。
  * Isolation隔离层:事务将假定只有它自己在操作数据库，彼此不知晓。
  * Durability: 一旦事务完成，就不能返回。
  * 跨数据库事务：2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland) 是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。

BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性：
  * Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库)
  * Soft state软状态 状态可以有一段时间不同步，异步。
  * Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时高一致。

BASE思想的主要实现有:
  1. 按功能划分数据库
  2. sharding碎片

BASE思想主要强调基本的可用性，如果你需要High 可用性，也就是纯粹的高性能，那么就要以一致性或容错性为牺牲，BASE思想的方案在性能上还是有潜力可挖的。

高可用数据:
  * 持久
  * 可访问
  * 一致性：cap
    * 数据强一致性: 副本跟物理存储一致
    * 用户一致: 副本跟物理存储可能不一致，但最终返回给用户的是一致的
    * 最终一致: 副本跟物理存储可能不一致，返回给用户的可能一致的，但经过一段时间后达到一致

失效转移：
  * 失效确认
  * 访问转移
  * 数据恢复

快速失效：fast failed，启动过程抛错就停止启动，而不是启动后执行错误操作

不允许没有监控的系统上线

自动优雅降级：自动关闭某些非核心功能释放资源

网站架构伸缩:
不同功能物理分离：将功能安装到新增服务器中
同一功能集群伸缩

http重定向负载
dns域名解析负载
反向代理负载
ip负载菌核
数据链路层负载：修改目的mac 三角传输 LVS

算法：
轮询 round robin
加权轮询 weighted round robin
随机
最少链接
源地址散列

计算机的任何问题都可以通过增加一个虚拟层解决

XSS攻击：cross site script
  * 反射型
  * 持久型

cookie中设置httponly属性，禁止页面的js访问

注入攻击： sql注入 os注入

CSRF: cross site request forgery

modsecurity web防御

加密：
  * 单向散列加密 md5 sha
  * 对称加密：DES RC
  * 非对称加密：RSA

秘钥安全：
秘钥服务器
加密算法放在应用系统，秘钥放服务器，分割存储

付费来解决后勤，全力拓展业务

针对不同故障的高可用方案
瞬时
临时
永久

秒杀系统设计：
* 独立部署
* 页面静态化
* 租借带宽
* 下单URL随机生成 防止提前下单

js+salt生成下单按钮
只允许第一个提交的订单

价值在于经历过多少故障，而不是掌握了多少技术

设计风格：
  * 将软件设计的很复杂以至于缺陷没有那么明显
  * 将软件设计的简单以至于没有那么明显的缺陷

是事情成就了人，而不是人成就了事情

蓝图应该是表述清楚的，形象的，简单的

我一闭上眼睛，就看到中国的明天

提问tips:
  * 把我的问题表述成我们的问题
  * 给上司提封闭式问题，下属提开放式问题
  * 指出问题而不是批评人
  * 用赞同的方式提问

解决问题tips:
* 在解决我的问题之前解决你的问题
* 适当逃避问题

架构师划分：
  * 设计型： 设计 落地
  * 救火型： 公司元老，大牛
  * 步道型： 对某一领域有深刻人生乐于分享，希望推广自己对技术主张，但有时由于自身局限或不能跟上技术潮流而成为忽悠型和偶像型
  * Geek型：技术偏执，完美型
  
事件驱动架构：event driven architecture
典型架构：生产者消费者

